https://modoocode.com/135

1-2. 첫 C++ 프로그램 분석하기
- namespace에 이름을 지정하지 않으면, 해당 파일에서만 접근이 가능하고 static으로 동작한다.
- using namespace std; 는 권장하지 않는다. 너무 거대하고 버전별 차이가 많이 때문


2-2. C++은 C 친구일까
- 레퍼런스 & 로 변수를 받으면 하나의 별명이 된다.
- 레퍼런스는 정의시 반드시 초기화 되어야 한다. 컴파일시 원래 가리키던 변수의 주소값으로 치환된다.
- 상수에 대한 참조를 하려면 const 키워드를 사용한다.
- 레퍼런스의 배열은 불가, 배열의 레퍼런스는 가능
- 레퍼런스를 리턴하는 함수는 헷갈리는 부분이니 더 공부해보자. 우측값 관련됨


4 - 1. 이 세상은 객체로 이루어져 있다
- 클래스는 객체를 만들어내는 설계도 라고 할 수 있다.
- static 멤버는 유일하게 존재하며 객체 간에 공유된다.


4 - 3. 스타크래프트를 만들자 ① (복사 생성자, 소멸자)
- 복사 생성자를 오버로딩 하지 않으면 default 복사 생성자를 쓰는데,
  동적 할당 같은 경우 포인터만 복사가 되므로 얕은 복사가 된다.
- 이럴땐 오버로딩 하여 Deep copy가 되도록 정의해야 한다.


4 - 6. 클래스의 explicit와 mutable 키워드
- explicit는 컴파일러가 묵시적으로 생성자를 찾아 실행하는 것을 막는다.
- const method 내에서는 멤버 변수의 값을 바꾸는 것이 불가능 하지만,
  mutable 로 멤버 변수를 선언하였다면 const 메소드에서도 변경이 가능하다.
- getUserInfo()에서 cache를 업데이트 하는것을 생각해볼 수 있다.


5 - 2.
- 두 개의 동등한 객체 사이에서의 이항 연산자는 멤버 함수가 아닌 외부 함수로 오버로딩 하는 것이 좋습니다. 
  (예를 들어 Complex 의 operator+(const Complex&, const Complex&) 와 같이 말입니다.)

- 두 개의 객체 사이의 이항 연산자 이지만 한 객체만 값이 바뀐다던지 등의 
  동등하지 않는 이항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다. 
  (예를 들어서 operator+= 는 이항 연산자 이지만 operator+=(const Complex&) 가 낫다)

- 단항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다 (예를 들어 operator++ 의 경우 멤버 함수로 오버로딩 합니다)

- 일부 연산자들은 반드시 멤버 함수로만 오버로딩 해야 합니다 (강좌 앞 부분 참고)


5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열
- static_cast : 우리가 흔히 생각하는, 언어적 차원에서 지원하는 일반적인 타입 변환
- const_cast : 객체의 상수성(const) 를 없애는 타입 변환. 쉽게 말해 const int 가 int 로 바뀐다.
- dynamic_cast : 파생 클래스 사이에서의 다운 캐스팅 (→ 정확한 의미는 나중에 다시 배울 것입니다)
- reinterpret_cast : 위험을 감수하고 하는 캐스팅으로 서로 관련이 없는 포인터들 사이의 캐스팅 등


6 - 1. C++ 표준 문자열 & 부모의 것을 물려쓰자 - 상속
- 만일 위처럼 public 형태로 상속 하였다면 기반 클래스의 접근 지시자들에 영향 없이 그대로 작동합니다.
- 즉 파생 클래스 입장에서 public 은 그대로 public 이고, protected 는 그대로 protected 이고, private 은 그대로 private 입니다.

- 만일 protected 로 상속하였다면 파생 클래스 입장에서 public 은 protected 로 바뀌고 나머지는 그대로 유지됩니다.

- 만일 private 으로 상속하였다면 파생 클래스 입장에서 모든 접근 지시자들이 private 가 됩니다.


6 - 2. 가상(virtual) 함수와 다형성
- dynamic_cast는 실행시간에 객체의 타입을 확인해서 메소드를 호출시킨다.
- virtual 키워드로 메소드를 정의하면 실행시간에 다형성에 따라 불리는 것이 달라진다.
- virtual 메소드를 overide 할때 자식 메소드에서  virtual 키워드를 안써도 되지만,
  헷갈릴 수 있으니 그냥 쓰자.


6 - 3. 가상함수와 상속에 관련한 잡다한 내용들
- 기반 클래스에서 파생 클래스의 함수에 접근할 때 항상 기반 클래스의 포인터를 통해서 접근하였습니다.
  하지만, 사실 기반 클래스의 레퍼런스여도 문제 없이 작동합니다.
- 가상 함수를 쓰면 vtable 관리 비용과 동적으로 타입을 결정해야하는 비용이 들어간다.
- 다중 상속시 상속 순서에 따라 생성자가 호출된다.
- 상속시 부모 생성자를 명시적으로 호출해야 된다는데.. 진짜? 아니다.
  기본 생성자를 호출함. 특정 생성자를 호출하고 싶으면 호출하면 됨.

- 다양한 기능을 하는 클래스의 디자인: 브리지 패턴, 중첩된 일반화, 다중 상속. 각 방법의 장단점이 있다.


9장. TMP 개념 이해

9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)
- 클래스 템플릿에 인자를 전달해서 실제 코드를 생성하는 것을 클래스 템플릿 인스턴스화 (class template instantiation) 라고 합니다.

- 템플릿이 인스턴스화 되지 않고 덩그러니 있다면 컴파일 시에 아무런 코드로 변환되지 않습니다.
  템플릿은 반드시 인스턴스화 되어야지만 비로소 컴파일러가 실제 코드를 생성하게 되지요.

- 함수 템플릿은 인스턴스화를 안해도 컴파일러가 알아서 해석한다.

- 함수 객체(Function Object - Functor)의 도입
  - struct 형태로 단순히 operator()만 정의
  - 함수는 아니지만 함수 인 척을 하는 객체를 함수 객체 (Function Object), 혹은 줄여서 Functor 라고 부릅니다.
  - 그렇다면 뭐가 더 나은 방법일까요? Functor? 아니면 구닥다리 함수 포인터?
  - 일단, 클래스 자체에 여러가지 내부 state 를 저장해서 비교 자체가 복잡한 경우에도
    손쉽게 사용자가 원하는 방식으로 만들어낼 수 있습니다.
  - 뿐만 아니라, 함수포인터로 함수를 받아서 처리한다면 컴파일러가 최적화를 할 수 없지만,
    Functor 를 넘기게 된다면 컴파일러가 operator() 자체를 인라인화 시켜서 매우 빠르게 작업을 수행할 수 있습니다.

- std::array 활용 하기
  - 배열처럼 컴파일 시에 스택에 할당됨
  - 메소드 인자로 넘길 때 템플릿을 쓰면 편하다.


9 - 2. 가변 길이 템플릿 (Variadic template)
- C++ 17 이전의 가변 길이 템플릿은 재귀적 호출을 이용했다.
  템플릿은 컴파일 때 결정이 되므로, 종료 조건의 메소드를 템플릿 메소드 이전에 작성해야 한다.

- 파라미터팩에 sizeof... 연산자를 사용할 경우 전체 인자의 개수를 리턴한다.

- C++ 17에 소개된 Fold expression을 통해 좀더 깔끔하게 표현이 가능하다.


9 - 3. 템플릿 메타 프로그래밍 (Template Meta programming)
- 템플릿을 사용하면 객체를 생성하지 않더라도, 타입에 어떠한 값 을 부여할 수 있고,
  또 그타입들을 가지고 연산 을 할 수 있다는 점 입니다.
- 또한 타입은 반드시 컴파일 타임에 확정되어야 하므로, 컴파일 타임에 모든 연산이 끝나게 됩니다.
  이렇게 타입을 가지고 컴파일 타임에 생성되는 코드로 프로그래밍을 하는 것을 메타 프로그래밍(meta programming) 이라고 합니다.
- TMP 를 왜 쓰는가?
  - 사실은어떠한 C++ 코드도 템플릿 메타 프로그래밍 코드로 변환할 수 있다는 점입니다(물론 엄청나게 코드가 길어지겠지만요).
  - 게다가 템플릿 메타 프로그래밍으로 작성된 코드는 모두 컴파일 타임에 모든 연산이 끝나기 때문에
     프로그램 실행 속도를 향상 시킬 수 있다는 장점이 있습니다 (당연히도 컴파일 시간은 엄청 늘어나게 됩니다).
  - 단점: 코딩도 어렵고 디버깅도 어렵다

- C++11부터 typedeff 대신에 직관적인 using 키워드를 사용할 수 있다.
  - typedef Ratio_add<rat, rat2> rat3;
    using rat3 = Ratio_add<rat, rat2>;
  - typedef void (*func)(int, int);
    using func = void (*)(int, int);

- Ratio 예제: 마치 Ratio 클래스의 객체를 생성한 것 같지만, 실제로 생성된 객체는 한 개도 없고,
  단순히 타입들을 컴파일러가 만들어낸 것 뿐입니다.


10장. STL 활용법 익히기

12장. rvalue와 move semantic 확실히 하고 넘어갈것

15장. Thread : 매우 중요하고 프로젝트도 진행할 것


16 - 1. C++ 유니폼 초기화(Uniform Initialization)
  1) 균일한 초기화 (Uniform Initialization)
    - A a(); => C++ 의 컴파일러는 함수의 정의처럼 보이는 것들은 모두 함수의 정의로 해석 
    - 생성자를 호출하기 위해 ()를 사용하는 대신에 {}를 사용
    - 큰 차이점은 일부 암시적 타입 변환들을 불허함
      - 부동 소수점 타입에서 정수 타입으로의 변환 (우리의 예시지요)
      - long double 에서 double 혹은 float 으로의 변환, double 에서 float 으로의 변환.
      - 정수 타입에서 부동 소수점 타입으로의 변환
    - 함수 리턴 시에 굳이 생성하는 객체의 타입을 다시 명시하지 않아도 됨

  2) 초기화자 리스트 (Initializer list)
    - initializer_list 는 우리가 {} 를 이용해서 생성자를 호출할 때,
      클래스의 생성자들 중에 initializer_list 를 인자로 받는 생성자가 있다면 전달됩니다.
    - std::vector<int> v = {1, 2, 3, 4, 5};
    - 생성자들 중에서 initializer_list 를 받는 생성자가 있다면 주의할 점
      => 만일 {}를 이용해서 객체를 생성할 경우 생성자 오버로딩 시에 해당 함수가 최우선으로 고려됨
      => vector v{10}; => 10을 보관하는 벡터 생성
	  => 컴파일러가 최선을 다해서 해당 생성자와 매칭시키려고 노력

  3) initializer_list 와 auto
    - auto x = {arg1, arg2...} 형태의 경우 arg1, arg2 ... 들이 모두 같은 타입이라면 x 는 std::initializer_list<T> 로 추론됩니다.
    - auto x {arg1. arg2, ...} 형태의 경우 만일 인자가 단 1 개라면 인자의 타입으로 추론되고, 여러 개일 경우 오류를 발생시킵니다.

 정리:
  - 유니폼 초기화 ({} 를 이용한 생성자 호출) 를 통해서 인자 없는 생성자가
    함수의 정의로 오해되는 일을 막을 수 있으며 initializer_list 를 만들어 전달할 수 있습니다.
  - initializer_list 를 통해서 객체를 간단하게 생성할 수 있습니다.

16 - 2. constexpr 와 함께라면 컴파일 타임 상수는 문제없어
  - constexpr : 객체나 함수 앞에 붙이면 해당 객체나 함수의 리턴값을 컴파일 타임에 값을 알 수 있다는 뜻
  - 컴파일 타임에 어떠한 식의 값을 결정할 수 있다면 Constant expression이라고 함
    특히 Integral constant expression의 쓰임이 많다

  1) constexpr vs const
    - const 로 정의된 상수들은 굳이 컴파일 타임에 그 값을 알 필요가 없다.
	- constexpr은 항상 const 이지만, const는 constexpr이 아니다.

  2) constexpr 함수
    - A<factorial(5)> a; => 기존에는 TMP를 활용해야 했다.
	- 하지만 함수의 리턴 타입에 constexpr 을 추가한다면 조건이 맞을 때,
	  해당 함수의 리턴값을 컴파일 타임 상수로 만들어버릴 수 있습니다.
    - 제약조건:
	  - goto 문 사용
	  - 예외 처리 (try 문; C++ 20 부터 가능하게 바뀌었습니다.)
	  - 리터럴 타입이 아닌 변수의 정의
	  - 초기화 되지 않는 변수의 정의
	  - 실행 중간에 constexpr 이 아닌 함수를 호출하게 됨
	- constexpr 함수에 인자로 컴파일 타임 상수가 아닌 값을 전달하면 일반함수로 동작

  3) 리터럴 타입: 컴파일러가 컴파일 타임에 정의할 수 있는 타입
    - void 형
	- 스칼라 타입 (char, int, bool, long, float, double) 등등
	- 레퍼런스 타입
	- 리터럴 타입의 배열
	- 혹은 아래 조건들을 만족하는 타입
	  - 디폴트 소멸자를 가지고
	  - 다음 중 하나를 만족하는 타입
	    - 람다 함수
        - Arggregate 타입 (사용자 정의 생성자, 소멸자가 없으며 모든 데이터 멤버들이 public)
	      쉽게 말해 pair 같은 애들을 이야기함
		- constexpr 생성자를 가지며 복사 및 이동 생성자가 없음
	
	- C++ 14 부터 constexpr 생성자를 지원함으로써 사용자들이 리터럴 타입들을 직접 만들 수 있게 되었습니다.

  4) constexpr 생성자


  5) if constexpr


