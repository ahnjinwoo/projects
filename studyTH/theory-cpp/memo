https://modoocode.com/135

1-2. 첫 C++ 프로그램 분석하기
- namespace에 이름을 지정하지 않으면, 해당 파일에서만 접근이 가능하고 static으로 동작한다.
- using namespace std; 는 권장하지 않는다. 너무 거대하고 버전별 차이가 많이 때문


2-2. C++은 C 친구일까
- 레퍼런스 & 로 변수를 받으면 하나의 별명이 된다.
- 레퍼런스는 정의시 반드시 초기화 되어야 한다. 컴파일시 원래 가리키던 변수의 주소값으로 치환된다.
- 상수에 대한 참조를 하려면 const 키워드를 사용한다.
- 레퍼런스의 배열은 불가, 배열의 레퍼런스는 가능
- 레퍼런스를 리턴하는 함수는 헷갈리는 부분이니 더 공부해보자. 우측값 관련됨


4 - 1. 이 세상은 객체로 이루어져 있다
- 클래스는 객체를 만들어내는 설계도 라고 할 수 있다.
- static 멤버는 유일하게 존재하며 객체 간에 공유된다.


4 - 3. 스타크래프트를 만들자 ① (복사 생성자, 소멸자)
- 복사 생성자를 오버로딩 하지 않으면 default 복사 생성자를 쓰는데,
  동적 할당 같은 경우 포인터만 복사가 되므로 얕은 복사가 된다.
- 이럴땐 오버로딩 하여 Deep copy가 되도록 정의해야 한다.


4 - 6. 클래스의 explicit와 mutable 키워드
- explicit는 컴파일러가 묵시적으로 생성자를 찾아 실행하는 것을 막는다.
- const method 내에서는 멤버 변수의 값을 바꾸는 것이 불가능 하지만,
  mutable 로 멤버 변수를 선언하였다면 const 메소드에서도 변경이 가능하다.
- getUserInfo()에서 cache를 업데이트 하는것을 생각해볼 수 있다.


5 - 2.
- 두 개의 동등한 객체 사이에서의 이항 연산자는 멤버 함수가 아닌 외부 함수로 오버로딩 하는 것이 좋습니다. 
  (예를 들어 Complex 의 operator+(const Complex&, const Complex&) 와 같이 말입니다.)

- 두 개의 객체 사이의 이항 연산자 이지만 한 객체만 값이 바뀐다던지 등의 
  동등하지 않는 이항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다. 
  (예를 들어서 operator+= 는 이항 연산자 이지만 operator+=(const Complex&) 가 낫다)

- 단항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다 (예를 들어 operator++ 의 경우 멤버 함수로 오버로딩 합니다)

- 일부 연산자들은 반드시 멤버 함수로만 오버로딩 해야 합니다 (강좌 앞 부분 참고)


5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열
- static_cast : 우리가 흔히 생각하는, 언어적 차원에서 지원하는 일반적인 타입 변환
- const_cast : 객체의 상수성(const) 를 없애는 타입 변환. 쉽게 말해 const int 가 int 로 바뀐다.
- dynamic_cast : 파생 클래스 사이에서의 다운 캐스팅 (→ 정확한 의미는 나중에 다시 배울 것입니다)
- reinterpret_cast : 위험을 감수하고 하는 캐스팅으로 서로 관련이 없는 포인터들 사이의 캐스팅 등


6 - 1. C++ 표준 문자열 & 부모의 것을 물려쓰자 - 상속
- 만일 위처럼 public 형태로 상속 하였다면 기반 클래스의 접근 지시자들에 영향 없이 그대로 작동합니다.
- 즉 파생 클래스 입장에서 public 은 그대로 public 이고, protected 는 그대로 protected 이고, private 은 그대로 private 입니다.

- 만일 protected 로 상속하였다면 파생 클래스 입장에서 public 은 protected 로 바뀌고 나머지는 그대로 유지됩니다.

- 만일 private 으로 상속하였다면 파생 클래스 입장에서 모든 접근 지시자들이 private 가 됩니다.


6 - 2. 가상(virtual) 함수와 다형성
- dynamic_cast는 실행시간에 객체의 타입을 확인해서 메소드를 호출시킨다.
- virtual 키워드로 메소드를 정의하면 실행시간에 다형성에 따라 불리는 것이 달라진다.
- virtual 메소드를 overide 할때 자식 메소드에서  virtual 키워드를 안써도 되지만,
  헷갈릴 수 있으니 그냥 쓰자.


6 - 3. 가상함수와 상속에 관련한 잡다한 내용들
- 기반 클래스에서 파생 클래스의 함수에 접근할 때 항상 기반 클래스의 포인터를 통해서 접근하였습니다.
  하지만, 사실 기반 클래스의 레퍼런스여도 문제 없이 작동합니다.
- 가상 함수를 쓰면 vtable 관리 비용과 동적으로 타입을 결정해야하는 비용이 들어간다.
- 다중 상속시 상속 순서에 따라 생성자가 호출된다.
- 상속시 부모 생성자를 명시적으로 호출해야 된다는데.. 진짜? 아니다.
  기본 생성자를 호출함. 특정 생성자를 호출하고 싶으면 호출하면 됨.

- 다양한 기능을 하는 클래스의 디자인: 브리지 패턴, 중첩된 일반화, 다중 상속. 각 방법의 장단점이 있다.


9장. TMP 개념 이해

9 - 1. 코드를 찍어내는 틀 - C++ 템플릿(template)
- 클래스 템플릿에 인자를 전달해서 실제 코드를 생성하는 것을 클래스 템플릿 인스턴스화 (class template instantiation) 라고 합니다.

- 템플릿이 인스턴스화 되지 않고 덩그러니 있다면 컴파일 시에 아무런 코드로 변환되지 않습니다.
  템플릿은 반드시 인스턴스화 되어야지만 비로소 컴파일러가 실제 코드를 생성하게 되지요.

- 함수 템플릿은 인스턴스화를 안해도 컴파일러가 알아서 해석한다.

- 함수 객체(Function Object - Functor)의 도입
  - struct 형태로 단순히 operator()만 정의
  - 함수는 아니지만 함수 인 척을 하는 객체를 함수 객체 (Function Object), 혹은 줄여서 Functor 라고 부릅니다.
  - 그렇다면 뭐가 더 나은 방법일까요? Functor? 아니면 구닥다리 함수 포인터?
  - 일단, 클래스 자체에 여러가지 내부 state 를 저장해서 비교 자체가 복잡한 경우에도
    손쉽게 사용자가 원하는 방식으로 만들어낼 수 있습니다.
  - 뿐만 아니라, 함수포인터로 함수를 받아서 처리한다면 컴파일러가 최적화를 할 수 없지만,
    Functor 를 넘기게 된다면 컴파일러가 operator() 자체를 인라인화 시켜서 매우 빠르게 작업을 수행할 수 있습니다.

- std::array 활용 하기
  - 배열처럼 컴파일 시에 스택에 할당됨
  - 메소드 인자로 넘길 때 템플릿을 쓰면 편하다.


9 - 2. 가변 길이 템플릿 (Variadic template)
- C++ 17 이전의 가변 길이 템플릿은 재귀적 호출을 이용했다.
  템플릿은 컴파일 때 결정이 되므로, 종료 조건의 메소드를 템플릿 메소드 이전에 작성해야 한다.

- 파라미터팩에 sizeof... 연산자를 사용할 경우 전체 인자의 개수를 리턴한다.

- C++ 17에 소개된 Fold expression을 통해 좀더 깔끔하게 표현이 가능하다.


9 - 3. 템플릿 메타 프로그래밍 (Template Meta programming)
- 템플릿을 사용하면 객체를 생성하지 않더라도, 타입에 어떠한 값 을 부여할 수 있고,
  또 그타입들을 가지고 연산 을 할 수 있다는 점 입니다.
- 또한 타입은 반드시 컴파일 타임에 확정되어야 하므로, 컴파일 타임에 모든 연산이 끝나게 됩니다.
  이렇게 타입을 가지고 컴파일 타임에 생성되는 코드로 프로그래밍을 하는 것을 메타 프로그래밍(meta programming) 이라고 합니다.
- TMP 를 왜 쓰는가?
  - 사실은어떠한 C++ 코드도 템플릿 메타 프로그래밍 코드로 변환할 수 있다는 점입니다(물론 엄청나게 코드가 길어지겠지만요).
  - 게다가 템플릿 메타 프로그래밍으로 작성된 코드는 모두 컴파일 타임에 모든 연산이 끝나기 때문에
     프로그램 실행 속도를 향상 시킬 수 있다는 장점이 있습니다 (당연히도 컴파일 시간은 엄청 늘어나게 됩니다).
  - 단점: 코딩도 어렵고 디버깅도 어렵다

- C++11부터 typedeff 대신에 직관적인 using 키워드를 사용할 수 있다.
  - typedef Ratio_add<rat, rat2> rat3;
    using rat3 = Ratio_add<rat, rat2>;
  - typedef void (*func)(int, int);
    using func = void (*)(int, int);

- Ratio 예제: 마치 Ratio 클래스의 객체를 생성한 것 같지만, 실제로 생성된 객체는 한 개도 없고,
  단순히 타입들을 컴파일러가 만들어낸 것 뿐입니다.


10장. STL 활용법 익히기

12장. rvalue와 move semantic 확실히 하고 넘어갈것
12 - 1. rvalue 레퍼런스와 이동 생성자
  1) 복사 생략
  - C++ 컴파일러는 복사를 생략할 때가 있다. 
    불필요한 복사는 지양해야 하며 rvalue를 이용해 이동을 구현해 줄 때가 있다.

  2) lvalue와 rvalue
  - 모든 C++ expression은 크게 두 가지 카테고리로 구분된다.
  - lvalue는 주소값을 취할 수 있는 값으로 주로 좌측에 위치.
    정빈이의 정의로는 사용자가 정의한 변수라고 한다.
  - rvalue는 주소값을 가져올 수 없는 임시값.
    정빈's 정의는 사용자가 정의하지 않았는데 컴파일러가 연산과정중 생성하는 변수(메모리)

  - & 연산자 한번만 쓰면 lvalue의 레퍼런스를 얻을 수 있다.
  - MyString str3 = str1 + str2;
  => MyString str3(str1.operator+(str2));
  => MyString MyString::operator+(const MyString &s) 가 어떻게 MyString(const MyString &str); 를 호출할 수 있을까?
  => & 가 lvalue reference를 의미하지만 예외적으로 const T& 의 타입에 한해서 rvalue도 reference로 받을 수 있다.

  3) 이동은 어떻게?
  - 기존 복사 생성자에서는 const MyString & 로 받았기 때문에 string_content의 값의 변경이 불가능
  - rvalue만 받을 수 있는 방법이 있어야 함

  4) rvalue reference
  - &를 두 개 사용해서 정의

  5) 이동 생성자 작성 시 주의할 점
  - MyString을 C++ 컨테이너 들, vector 에 넣기 위해서는 이동 생성자에 noexcept 키워드를 써야함
  - 이동하다가 예외 발생시 메모리 해제하면 안되기 때문.
  - vector의 경우 이동 생성자가 noexcept 가 아닌 이상 이동 생성자를 사용하지 않는다.

12 - 2. Move 문법 (std::move semantics) 과 완벽한 전달 (perfect forwarding)
  1) move semantics
  - 좌측값도 복사가 아닌 이동을 시키고 싶다면?
  - swap 할 때 std::move() 로 lvalue를 rvalue로 캐스팅 시키고, 대입 연산자를 &&을 받도록 재정의

  2) Perfect forwarding와 Universal Reference
  - wrapper 함수를 생각해보자. vector의 emplace_back 함수는 인자를 받으면 알아서 객체를 생성해서 추가시킴
  - 템플릿 인자 T에 대해서 우측값 레퍼런스를 받는 형태를 Universal reference라고 한다.
  - 이는 rvalue만 받는 레퍼런스와 다르다.
    rvalue 뿐만 아니라 lvalue도 받으며, reference collapsing rule에 따라 T의 타입을 추론함
  - typedef int& T;
    T& r1;   // int& &; r1 은 int&
    T&& r2;  // int & &&;  r2 는 int&

    typedef int&& U U& r3;  // int && &; r3 는 int&
    U&& r4;                 // int && &&; r4 는 int&&
  - 즉 쉽게 생각하면 & 는 1 이고 && 은 0 이라 둔 뒤에, OR 연산을 한다고 보면 됩니다.
  - forward 함수는 u가 우측값 레퍼런스 일 때만 move를 적용한 것처럼 동작

13 - 1. 객체의 유일한 소유권 - unique_ptr
  1) 자원 관리의 중요성
  - C++에서 한번 획득한 자원은 직접 해제해주지 않는 이상 남아있음
    예외 발생 등 다양한 이유로 메모리가 남아있게 됨
  - RAII: Resource Acquisition Is Initialization
    자원 관리를 스택에 할당한 객체를 통해 수행하는 것이다.
  - 예외가 발생해서 함수를 빠져나가더라도, 스택에 정의되어 있는 모든 객체들은 빠짐없이 소멸자가 호출
  
  2) unique_ptr : 객체의 유일한 소유권
  - 메모리 관리의 두가지 문제점: leak과 double free
  - 특정 객체에 유일한 소유권을 부여하는 포인터 객체를 unique_ptr 이라고 한다.
  - -> 연산자를 오버로드 해서 포인터와 동일하게 사용 가능

  3) = delete 키워드
  - C++ 11에 추가된 기능으로 메소드 삭제. 명시적으로 쓰지 말라는 뜻
  - unique_ptr의 복사 생성자는 삭제되어 복사할 수 없음
  - move semantic으로 소유권 이전은 가능하다. 이동 생성자는 있음

  4) unique_ptr을 함수에 레퍼런스로 전달은 가능하나, 취지에 맞지 않다.
  - ptr.get()을 써서 임시 접근

  5) std::make_unique 를 써서 편하게 생성하자. 템플릿 인자로 전달된 클래스의 생성자들에게 perfect forwarding 수행
    std::unique_ptr<Foo> ptr(new Foo(3, 5));
    auto ptr = std::make_unique<Foo>(3, 5);

  6) vector 컨테이너에 넣으려면 move를 쓰거나, emplace_back 이용하면 직접 생성하면서 넣을 수 있음.
     emplace_back이 직접 perfect forwarding 수행

    - std::vector<std::unique_ptr<A>> vec;
      std::unique_ptr<A> pa(new A(1));

      vec.push_back(std::move(pa));  // 잘 실행됨

    - std::vector<std::unique_ptr<A>> vec;

      // vec.push_back(std::unique_ptr<A>(new A(1))); 과 동일
      vec.emplace_back(new A(1));


13 - 2. 자원을 공유할 때 - shared_ptr 와 weak_ptr
  1) shared_ptr 로 객체를 가리킬 경우 다른 shared_ptr 역시 그 객체를 가리킬 수 있다.
  - 몇 개의 shared_ptr 들이 원래 객체를 가리키는지 알아야한다. 
    이를 reference count 라고 하며, 0가 되어야 객체를 해제할 수 있음
  - shared_ptr 끼리 공유하는 control block에 ref count를 기록함
  - make_shared를 통해 동적할당 횟수를 줄이자.
    => std::shared_ptr<A> p1(new A());
	=> std::shared_ptr<A> p1 = std::make_shared<A>();
  
  2) shared_ptr 은 인자로 주소값이 전달되면, 자기가 해당 객체를 첫번째로 소유하는 것처럼 행동함
  - A* a = new A();
    std::shared_ptr<A> pa1(a);
    std::shared_ptr<A> pa2(a);
  - 위의 경우 제어블록이 따로 생성됨. 
    this를 사용해 shared_ptr을 만들고 싶으면 enable_shared_from_this를 상속

  3) weak_ptr
  - 순환 참조 문제 해결을 위해 등장. 스마트 포인터처럼 객체를 안전하게 참조하지만, 참조 개수를 늘리지는 않음
  - weak_ptr 자체로는 원래 객체를 참조할 수 없고, 반드시 shared_ptr로 변환해서 사용
  - 가리키고 있는 객체가 이미 소멸되었다면 empty shared_ptr로 변환되고,
    아닐경우 해당 객체를 가리키는 shared_ptr 로 변환된다.

  - shared_ptr의 제어블록에는 weak count도 존재한다.
  - shared_ptr은 0개 지만 아직 weak_ptr이 남아있을 때, 물론 객체는 해제되어 있는 상태이지만
    제어블록마저 해제해 버리면 제어 블록에서 참조 카운트가 0이라는 사실을 알 수 없다.

13장 연습문제
  - 가계도 관리 라이브러리

14. 함수를 객체로! (C++ std::function, std::mem_fn, std::bind)


15장. Thread : 매우 중요하고 프로젝트도 진행할 것


16 - 1. C++ 유니폼 초기화(Uniform Initialization)
  1) 균일한 초기화 (Uniform Initialization)
    - A a(); => C++ 의 컴파일러는 함수의 정의처럼 보이는 것들은 모두 함수의 정의로 해석 
    - 생성자를 호출하기 위해 ()를 사용하는 대신에 {}를 사용
    - 큰 차이점은 일부 암시적 타입 변환들을 불허함
      - 부동 소수점 타입에서 정수 타입으로의 변환 (우리의 예시지요)
      - long double 에서 double 혹은 float 으로의 변환, double 에서 float 으로의 변환.
      - 정수 타입에서 부동 소수점 타입으로의 변환
    - 함수 리턴 시에 굳이 생성하는 객체의 타입을 다시 명시하지 않아도 됨

  2) 초기화자 리스트 (Initializer list)
    - initializer_list 는 우리가 {} 를 이용해서 생성자를 호출할 때,
      클래스의 생성자들 중에 initializer_list 를 인자로 받는 생성자가 있다면 전달됩니다.
    - std::vector<int> v = {1, 2, 3, 4, 5};
    - 생성자들 중에서 initializer_list 를 받는 생성자가 있다면 주의할 점
      => 만일 {}를 이용해서 객체를 생성할 경우 생성자 오버로딩 시에 해당 함수가 최우선으로 고려됨
      => vector v{10}; => 10을 보관하는 벡터 생성
	  => 컴파일러가 최선을 다해서 해당 생성자와 매칭시키려고 노력

  3) initializer_list 와 auto
    - auto x = {arg1, arg2...} 형태의 경우 arg1, arg2 ... 들이 모두 같은 타입이라면 x 는 std::initializer_list<T> 로 추론됩니다.
    - auto x {arg1. arg2, ...} 형태의 경우 만일 인자가 단 1 개라면 인자의 타입으로 추론되고, 여러 개일 경우 오류를 발생시킵니다.

 정리:
  - 유니폼 초기화 ({} 를 이용한 생성자 호출) 를 통해서 인자 없는 생성자가
    함수의 정의로 오해되는 일을 막을 수 있으며 initializer_list 를 만들어 전달할 수 있습니다.
  - initializer_list 를 통해서 객체를 간단하게 생성할 수 있습니다.

16 - 2. constexpr 와 함께라면 컴파일 타임 상수는 문제없어
  - constexpr : 객체나 함수 앞에 붙이면 해당 객체나 함수의 리턴값을 컴파일 타임에 값을 알 수 있다는 뜻
  - 컴파일 타임에 어떠한 식의 값을 결정할 수 있다면 Constant expression이라고 함
    특히 Integral constant expression의 쓰임이 많다

  1) constexpr vs const
    - const 로 정의된 상수들은 굳이 컴파일 타임에 그 값을 알 필요가 없다.
	- constexpr은 항상 const 이지만, const는 constexpr이 아니다.

  2) constexpr 함수
    - A<factorial(5)> a; => 기존에는 TMP를 활용해야 했다.
	- 하지만 함수의 리턴 타입에 constexpr 을 추가한다면 조건이 맞을 때,
	  해당 함수의 리턴값을 컴파일 타임 상수로 만들어버릴 수 있습니다.
    - 제약조건:
	  - goto 문 사용
	  - 예외 처리 (try 문; C++ 20 부터 가능하게 바뀌었습니다.)
	  - 리터럴 타입이 아닌 변수의 정의
	  - 초기화 되지 않는 변수의 정의
	  - 실행 중간에 constexpr 이 아닌 함수를 호출하게 됨
	- constexpr 함수에 인자로 컴파일 타임 상수가 아닌 값을 전달하면 일반함수로 동작

  3) 리터럴 타입: 컴파일러가 컴파일 타임에 정의할 수 있는 타입
    - void 형
	- 스칼라 타입 (char, int, bool, long, float, double) 등등
	- 레퍼런스 타입
	- 리터럴 타입의 배열
	- 혹은 아래 조건들을 만족하는 타입
	  - 디폴트 소멸자를 가지고
	  - 다음 중 하나를 만족하는 타입
	    - 람다 함수
        - Arggregate 타입 (사용자 정의 생성자, 소멸자가 없으며 모든 데이터 멤버들이 public)
	      쉽게 말해 pair 같은 애들을 이야기함
		- constexpr 생성자를 가지며 복사 및 이동 생성자가 없음
	
	- C++ 14 부터 constexpr 생성자를 지원함으로써 사용자들이 리터럴 타입들을 직접 만들 수 있게 되었습니다.

  4) constexpr 생성자


  5) if constexpr


