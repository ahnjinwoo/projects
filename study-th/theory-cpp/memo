https://modoocode.com/135

1-2. 첫 C++ 프로그램 분석하기
- namespace에 이름을 지정하지 않으면, 해당 파일에서만 접근이 가능하고 static으로 동작한다.
- using namespace std; 는 권장하지 않는다. 너무 거대하고 버전별 차이가 많이 때문


2-2. C++은 C 친구일까
- 레퍼런스 & 로 변수를 받으면 하나의 별명이 된다.
- 레퍼런스는 정의시 반드시 초기화 되어야 한다. 컴파일시 원래 가리키던 변수의 주소값으로 치환된다.
- 상수에 대한 참조를 하려면 const 키워드를 사용한다.
- 레퍼런스의 배열은 불가, 배열의 레퍼런스는 가능
- 레퍼런스를 리턴하는 함수는 헷갈리는 부분이니 더 공부해보자. 우측값 관련됨

4 - 1. 이 세상은 객체로 이루어져 있다
- 클래스는 객체를 만들어내는 설계도 라고 할 수 있다.
- static 멤버는 유일하게 존재하며 객체 간에 공유된다.

4 - 3. 스타크래프트를 만들자 ① (복사 생성자, 소멸자)
- 복사 생성자를 오버로딩 하지 않으면 default 복사 생성자를 쓰는데,
  동적 할당 같은 경우 포인터만 복사가 되므로 얕은 복사가 된다.
- 이럴땐 오버로딩 하여 Deep copy가 되도록 정의해야 한다.

4-6. 클래스의 explicit와 mutable 키워드
- explicit는 컴파일러가 묵시적으로 생성자를 찾아 실행하는 것을 막는다.
- const method 내에서는 멤버 변수의 값을 바꾸는 것이 불가능 하지만,
  mutable 로 멤버 변수를 선언하였다면 const 메소드에서도 변경이 가능하다.
- getUserInfo()에서 cache를 업데이트 하는것을 생각해볼 수 있다.

5 - 2.
- 두 개의 동등한 객체 사이에서의 이항 연산자는 멤버 함수가 아닌 외부 함수로 오버로딩 하는 것이 좋습니다. 
  (예를 들어 Complex 의 operator+(const Complex&, const Complex&) 와 같이 말입니다.)

- 두 개의 객체 사이의 이항 연산자 이지만 한 객체만 값이 바뀐다던지 등의 
  동등하지 않는 이항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다. 
  (예를 들어서 operator+= 는 이항 연산자 이지만 operator+=(const Complex&) 가 낫다)

- 단항 연산자는 멤버 함수로 오버로딩 하는 것이 좋습니다 (예를 들어 operator++ 의 경우 멤버 함수로 오버로딩 합니다)

- 일부 연산자들은 반드시 멤버 함수로만 오버로딩 해야 합니다 (강좌 앞 부분 참고)

5 - 3. 연산자 오버로딩 프로젝트 - N 차원 배열
- static_cast : 우리가 흔히 생각하는, 언어적 차원에서 지원하는 일반적인 타입 변환
- const_cast : 객체의 상수성(const) 를 없애는 타입 변환. 쉽게 말해 const int 가 int 로 바뀐다.
- dynamic_cast : 파생 클래스 사이에서의 다운 캐스팅 (→ 정확한 의미는 나중에 다시 배울 것입니다)
- reinterpret_cast : 위험을 감수하고 하는 캐스팅으로 서로 관련이 없는 포인터들 사이의 캐스팅 등

6 - 1. C++ 표준 문자열 & 부모의 것을 물려쓰자 - 상속
- 만일 위처럼 public 형태로 상속 하였다면 기반 클래스의 접근 지시자들에 영향 없이 그대로 작동합니다.
- 즉 파생 클래스 입장에서 public 은 그대로 public 이고, protected 는 그대로 protected 이고, private 은 그대로 private 입니다.

- 만일 protected 로 상속하였다면 파생 클래스 입장에서 public 은 protected 로 바뀌고 나머지는 그대로 유지됩니다.

- 만일 private 으로 상속하였다면 파생 클래스 입장에서 모든 접근 지시자들이 private 가 됩니다.

6 - 2. 가상(virtual) 함수와 다형성
- dynamic_cast는 실행시간에 객체의 타입을 확인해서 메소드를 호출시킨다.
- virtual 키워드로 메소드를 정의하면 실행시간에 다형성에 따라 불리는 것이 달라진다.
- virtual 메소드를 overide 할때 자식 메소드에서  virtual 키워드를 안써도 되지만,
  헷갈릴 수 있으니 그냥 쓰자.

6 - 3. 가상함수와 상속에 관련한 잡다한 내용들
- 기반 클래스에서 파생 클래스의 함수에 접근할 때 항상 기반 클래스의 포인터를 통해서 접근하였습니다. 
  하지만, 사실 기반 클래스의 레퍼런스여도 문제 없이 작동합니다.
- 가상 함수를 쓰면 vtable 관리 비용과 동적으로 타입을 결정해야하는 비용이 들어간다.
- 다중 상속시 상속 순서에 따라 생성자가 호출된다.
- 상속시 부모 생성자를 명시적으로 호출해야 된다는데.. 진짜? 아니다.
  기본 생성자를 호출함. 특정 생성자를 호출하고 싶으면 호출하면 됨.

- 다양한 기능을 하는 클래스의 디자인: 브리지 패턴, 중첩된 일반화, 다중 상속. 각 방법의 장단점이 있다.



